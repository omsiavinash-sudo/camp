{"ast":null,"code":"import useEventCallback from '@mui/utils/useEventCallback';\nimport useTimeout from '@mui/utils/useTimeout';\nimport { useFieldRootHandleKeyDown } from \"./useFieldRootHandleKeyDown.js\";\nimport { getActiveElement } from \"../../utils/utils.js\";\nimport { syncSelectionToDOM } from \"./syncSelectionToDOM.js\";\n\n/**\n * Generate the props to pass to the root element of the field.\n * It is not used by the non-accessible DOM structure (with an <input /> element for editing).\n * It should be used in the MUI accessible DOM structure and the Base UI implementation.\n * @param {UseFieldRootPropsParameters} parameters The parameters of the hook.\n * @returns {UseFieldRootPropsReturnValue} The props to forward to the root element of the field.\n */\nexport function useFieldRootProps(parameters) {\n  const {\n    manager,\n    focused,\n    setFocused,\n    domGetters,\n    stateResponse,\n    applyCharacterEditing,\n    internalPropsWithDefaults,\n    stateResponse: {\n      // States and derived states\n      parsedSelectedSections,\n      sectionOrder,\n      state,\n      // Methods to update the states\n      clearValue,\n      setCharacterQuery,\n      setSelectedSections,\n      updateValueFromValueStr\n    },\n    internalPropsWithDefaults: {\n      disabled = false,\n      readOnly = false\n    }\n  } = parameters;\n\n  // TODO: Inline onContainerKeyDown once the old DOM structure is removed\n  const handleKeyDown = useFieldRootHandleKeyDown({\n    manager,\n    internalPropsWithDefaults,\n    stateResponse\n  });\n  const containerClickTimeout = useTimeout();\n  const handleClick = useEventCallback(event => {\n    if (disabled || !domGetters.isReady()) {\n      return;\n    }\n    setFocused(true);\n    if (parsedSelectedSections === 'all') {\n      containerClickTimeout.start(0, () => {\n        const cursorPosition = document.getSelection().getRangeAt(0).startOffset;\n        if (cursorPosition === 0) {\n          setSelectedSections(sectionOrder.startIndex);\n          return;\n        }\n        let sectionIndex = 0;\n        let cursorOnStartOfSection = 0;\n        while (cursorOnStartOfSection < cursorPosition && sectionIndex < state.sections.length) {\n          const section = state.sections[sectionIndex];\n          sectionIndex += 1;\n          cursorOnStartOfSection += \"\".concat(section.startSeparator).concat(section.value || section.placeholder).concat(section.endSeparator).length;\n        }\n        setSelectedSections(sectionIndex - 1);\n      });\n    } else if (!focused) {\n      setFocused(true);\n      setSelectedSections(sectionOrder.startIndex);\n    } else {\n      const hasClickedOnASection = domGetters.getRoot().contains(event.target);\n      if (!hasClickedOnASection) {\n        setSelectedSections(sectionOrder.startIndex);\n      }\n    }\n  });\n  const handleInput = useEventCallback(event => {\n    var _target$textContent;\n    if (!domGetters.isReady() || parsedSelectedSections !== 'all') {\n      return;\n    }\n    const target = event.target;\n    const keyPressed = (_target$textContent = target.textContent) !== null && _target$textContent !== void 0 ? _target$textContent : '';\n    domGetters.getRoot().innerHTML = state.sections.map(section => \"\".concat(section.startSeparator).concat(section.value || section.placeholder).concat(section.endSeparator)).join('');\n    syncSelectionToDOM({\n      focused,\n      domGetters,\n      stateResponse\n    });\n    if (keyPressed.length === 0 || keyPressed.charCodeAt(0) === 10) {\n      clearValue();\n      setSelectedSections('all');\n    } else if (keyPressed.length > 1) {\n      updateValueFromValueStr(keyPressed);\n    } else {\n      if (parsedSelectedSections === 'all') {\n        setSelectedSections(0);\n      }\n      applyCharacterEditing({\n        keyPressed,\n        sectionIndex: 0\n      });\n    }\n  });\n  const handlePaste = useEventCallback(event => {\n    if (readOnly || parsedSelectedSections !== 'all') {\n      event.preventDefault();\n      return;\n    }\n    const pastedValue = event.clipboardData.getData('text');\n    event.preventDefault();\n    setCharacterQuery(null);\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleFocus = useEventCallback(() => {\n    if (focused || disabled || !domGetters.isReady()) {\n      return;\n    }\n    const activeElement = getActiveElement(domGetters.getRoot());\n    setFocused(true);\n    const isFocusInsideASection = domGetters.getSectionIndexFromDOMElement(activeElement) != null;\n    if (!isFocusInsideASection) {\n      setSelectedSections(sectionOrder.startIndex);\n    }\n  });\n  const handleBlur = useEventCallback(() => {\n    setTimeout(() => {\n      if (!domGetters.isReady()) {\n        return;\n      }\n      const activeElement = getActiveElement(domGetters.getRoot());\n      const shouldBlur = !domGetters.getRoot().contains(activeElement);\n      if (shouldBlur) {\n        setFocused(false);\n        setSelectedSections(null);\n      }\n    });\n  });\n  return {\n    // Event handlers\n    onKeyDown: handleKeyDown,\n    onBlur: handleBlur,\n    onFocus: handleFocus,\n    onClick: handleClick,\n    onPaste: handlePaste,\n    onInput: handleInput,\n    // Other\n    contentEditable: parsedSelectedSections === 'all',\n    tabIndex: internalPropsWithDefaults.disabled || parsedSelectedSections === 0 ? -1 : 0 // TODO: Try to set to undefined when there is a section selected.\n  };\n}","map":{"version":3,"names":["useEventCallback","useTimeout","useFieldRootHandleKeyDown","getActiveElement","syncSelectionToDOM","useFieldRootProps","parameters","manager","focused","setFocused","domGetters","stateResponse","applyCharacterEditing","internalPropsWithDefaults","parsedSelectedSections","sectionOrder","state","clearValue","setCharacterQuery","setSelectedSections","updateValueFromValueStr","disabled","readOnly","handleKeyDown","containerClickTimeout","handleClick","event","isReady","start","cursorPosition","document","getSelection","getRangeAt","startOffset","startIndex","sectionIndex","cursorOnStartOfSection","sections","length","section","concat","startSeparator","value","placeholder","endSeparator","hasClickedOnASection","getRoot","contains","target","handleInput","_target$textContent","keyPressed","textContent","innerHTML","map","join","charCodeAt","handlePaste","preventDefault","pastedValue","clipboardData","getData","handleFocus","activeElement","isFocusInsideASection","getSectionIndexFromDOMElement","handleBlur","setTimeout","shouldBlur","onKeyDown","onBlur","onFocus","onClick","onPaste","onInput","contentEditable","tabIndex"],"sources":["/home/ubuntu/application/frontend/node_modules/@mui/x-date-pickers/esm/internals/hooks/useField/useFieldRootProps.js"],"sourcesContent":["import useEventCallback from '@mui/utils/useEventCallback';\nimport useTimeout from '@mui/utils/useTimeout';\nimport { useFieldRootHandleKeyDown } from \"./useFieldRootHandleKeyDown.js\";\nimport { getActiveElement } from \"../../utils/utils.js\";\nimport { syncSelectionToDOM } from \"./syncSelectionToDOM.js\";\n\n/**\n * Generate the props to pass to the root element of the field.\n * It is not used by the non-accessible DOM structure (with an <input /> element for editing).\n * It should be used in the MUI accessible DOM structure and the Base UI implementation.\n * @param {UseFieldRootPropsParameters} parameters The parameters of the hook.\n * @returns {UseFieldRootPropsReturnValue} The props to forward to the root element of the field.\n */\nexport function useFieldRootProps(parameters) {\n  const {\n    manager,\n    focused,\n    setFocused,\n    domGetters,\n    stateResponse,\n    applyCharacterEditing,\n    internalPropsWithDefaults,\n    stateResponse: {\n      // States and derived states\n      parsedSelectedSections,\n      sectionOrder,\n      state,\n      // Methods to update the states\n      clearValue,\n      setCharacterQuery,\n      setSelectedSections,\n      updateValueFromValueStr\n    },\n    internalPropsWithDefaults: {\n      disabled = false,\n      readOnly = false\n    }\n  } = parameters;\n\n  // TODO: Inline onContainerKeyDown once the old DOM structure is removed\n  const handleKeyDown = useFieldRootHandleKeyDown({\n    manager,\n    internalPropsWithDefaults,\n    stateResponse\n  });\n  const containerClickTimeout = useTimeout();\n  const handleClick = useEventCallback(event => {\n    if (disabled || !domGetters.isReady()) {\n      return;\n    }\n    setFocused(true);\n    if (parsedSelectedSections === 'all') {\n      containerClickTimeout.start(0, () => {\n        const cursorPosition = document.getSelection().getRangeAt(0).startOffset;\n        if (cursorPosition === 0) {\n          setSelectedSections(sectionOrder.startIndex);\n          return;\n        }\n        let sectionIndex = 0;\n        let cursorOnStartOfSection = 0;\n        while (cursorOnStartOfSection < cursorPosition && sectionIndex < state.sections.length) {\n          const section = state.sections[sectionIndex];\n          sectionIndex += 1;\n          cursorOnStartOfSection += `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`.length;\n        }\n        setSelectedSections(sectionIndex - 1);\n      });\n    } else if (!focused) {\n      setFocused(true);\n      setSelectedSections(sectionOrder.startIndex);\n    } else {\n      const hasClickedOnASection = domGetters.getRoot().contains(event.target);\n      if (!hasClickedOnASection) {\n        setSelectedSections(sectionOrder.startIndex);\n      }\n    }\n  });\n  const handleInput = useEventCallback(event => {\n    if (!domGetters.isReady() || parsedSelectedSections !== 'all') {\n      return;\n    }\n    const target = event.target;\n    const keyPressed = target.textContent ?? '';\n    domGetters.getRoot().innerHTML = state.sections.map(section => `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`).join('');\n    syncSelectionToDOM({\n      focused,\n      domGetters,\n      stateResponse\n    });\n    if (keyPressed.length === 0 || keyPressed.charCodeAt(0) === 10) {\n      clearValue();\n      setSelectedSections('all');\n    } else if (keyPressed.length > 1) {\n      updateValueFromValueStr(keyPressed);\n    } else {\n      if (parsedSelectedSections === 'all') {\n        setSelectedSections(0);\n      }\n      applyCharacterEditing({\n        keyPressed,\n        sectionIndex: 0\n      });\n    }\n  });\n  const handlePaste = useEventCallback(event => {\n    if (readOnly || parsedSelectedSections !== 'all') {\n      event.preventDefault();\n      return;\n    }\n    const pastedValue = event.clipboardData.getData('text');\n    event.preventDefault();\n    setCharacterQuery(null);\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleFocus = useEventCallback(() => {\n    if (focused || disabled || !domGetters.isReady()) {\n      return;\n    }\n    const activeElement = getActiveElement(domGetters.getRoot());\n    setFocused(true);\n    const isFocusInsideASection = domGetters.getSectionIndexFromDOMElement(activeElement) != null;\n    if (!isFocusInsideASection) {\n      setSelectedSections(sectionOrder.startIndex);\n    }\n  });\n  const handleBlur = useEventCallback(() => {\n    setTimeout(() => {\n      if (!domGetters.isReady()) {\n        return;\n      }\n      const activeElement = getActiveElement(domGetters.getRoot());\n      const shouldBlur = !domGetters.getRoot().contains(activeElement);\n      if (shouldBlur) {\n        setFocused(false);\n        setSelectedSections(null);\n      }\n    });\n  });\n  return {\n    // Event handlers\n    onKeyDown: handleKeyDown,\n    onBlur: handleBlur,\n    onFocus: handleFocus,\n    onClick: handleClick,\n    onPaste: handlePaste,\n    onInput: handleInput,\n    // Other\n    contentEditable: parsedSelectedSections === 'all',\n    tabIndex: internalPropsWithDefaults.disabled || parsedSelectedSections === 0 ? -1 : 0 // TODO: Try to set to undefined when there is a section selected.\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}