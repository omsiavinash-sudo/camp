{"ast":null,"code":"import { getMonthsInYear } from \"../../utils/date-utils.js\";\nexport const getDateSectionConfigFromFormatToken = (adapter, formatToken) => {\n  const config = adapter.formatTokenMap[formatToken];\n  if (config == null) {\n    throw new Error([\"MUI X: The token \\\"\".concat(formatToken, \"\\\" is not supported by the Date and Time Pickers.\"), 'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.'].join('\\n'));\n  }\n  if (typeof config === 'string') {\n    return {\n      type: config,\n      contentType: config === 'meridiem' ? 'letter' : 'digit',\n      maxLength: undefined\n    };\n  }\n  return {\n    type: config.sectionType,\n    contentType: config.contentType,\n    maxLength: config.maxLength\n  };\n};\nexport const getDaysInWeekStr = (adapter, format) => {\n  const elements = [];\n  const now = adapter.date(undefined, 'default');\n  const startDate = adapter.startOfWeek(now);\n  const endDate = adapter.endOfWeek(now);\n  let current = startDate;\n  while (adapter.isBefore(current, endDate)) {\n    elements.push(current);\n    current = adapter.addDays(current, 1);\n  }\n  return elements.map(weekDay => adapter.formatByString(weekDay, format));\n};\nexport const getLetterEditingOptions = (adapter, timezone, sectionType, format) => {\n  switch (sectionType) {\n    case 'month':\n      {\n        return getMonthsInYear(adapter, adapter.date(undefined, timezone)).map(month => adapter.formatByString(month, format));\n      }\n    case 'weekDay':\n      {\n        return getDaysInWeekStr(adapter, format);\n      }\n    case 'meridiem':\n      {\n        const now = adapter.date(undefined, timezone);\n        return [adapter.startOfDay(now), adapter.endOfDay(now)].map(date => adapter.formatByString(date, format));\n      }\n    default:\n      {\n        return [];\n      }\n  }\n};\n\n// This format should be the same on all the adapters\n// If some adapter does not respect this convention, then we will need to hardcode the format on each adapter.\nexport const FORMAT_SECONDS_NO_LEADING_ZEROS = 's';\nconst NON_LOCALIZED_DIGITS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\nexport const getLocalizedDigits = adapter => {\n  const today = adapter.date(undefined);\n  const formattedZero = adapter.formatByString(adapter.setSeconds(today, 0), FORMAT_SECONDS_NO_LEADING_ZEROS);\n  if (formattedZero === '0') {\n    return NON_LOCALIZED_DIGITS;\n  }\n  return Array.from({\n    length: 10\n  }).map((_, index) => adapter.formatByString(adapter.setSeconds(today, index), FORMAT_SECONDS_NO_LEADING_ZEROS));\n};\nexport const removeLocalizedDigits = (valueStr, localizedDigits) => {\n  if (localizedDigits[0] === '0') {\n    return valueStr;\n  }\n  const digits = [];\n  let currentFormattedDigit = '';\n  for (let i = 0; i < valueStr.length; i += 1) {\n    currentFormattedDigit += valueStr[i];\n    const matchingDigitIndex = localizedDigits.indexOf(currentFormattedDigit);\n    if (matchingDigitIndex > -1) {\n      digits.push(matchingDigitIndex.toString());\n      currentFormattedDigit = '';\n    }\n  }\n  return digits.join('');\n};\nexport const applyLocalizedDigits = (valueStr, localizedDigits) => {\n  if (localizedDigits[0] === '0') {\n    return valueStr;\n  }\n  return valueStr.split('').map(char => localizedDigits[Number(char)]).join('');\n};\nexport const isStringNumber = (valueStr, localizedDigits) => {\n  const nonLocalizedValueStr = removeLocalizedDigits(valueStr, localizedDigits);\n  // `Number(' ')` returns `0` even if ' ' is not a valid number.\n  return nonLocalizedValueStr !== ' ' && !Number.isNaN(Number(nonLocalizedValueStr));\n};\n\n/**\n * Make sure the value of a digit section have the right amount of leading zeros.\n * E.g.: `03` => `3`\n * Warning: Should only be called with non-localized digits. Call `removeLocalizedDigits` with your value if needed.\n */\nexport const cleanLeadingZeros = (valueStr, size) => {\n  // Remove the leading zeros and then add back as many as needed.\n  return Number(valueStr).toString().padStart(size, '0');\n};\nexport const cleanDigitSectionValue = (adapter, value, sectionBoundaries, localizedDigits, section) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (section.type !== 'day' && section.contentType === 'digit-with-letter') {\n      throw new Error([\"MUI X: The token \\\"\".concat(section.format, \"\\\" is a digit format with letter in it.'\\n             This type of format is only supported for 'day' sections\")].join('\\n'));\n    }\n  }\n  if (section.type === 'day' && section.contentType === 'digit-with-letter') {\n    const date = adapter.setDate(sectionBoundaries.longestMonth, value);\n    return adapter.formatByString(date, section.format);\n  }\n\n  // queryValue without leading `0` (`01` => `1`)\n  let valueStr = value.toString();\n  if (section.hasLeadingZerosInInput) {\n    valueStr = cleanLeadingZeros(valueStr, section.maxLength);\n  }\n  return applyLocalizedDigits(valueStr, localizedDigits);\n};\nexport const getSectionVisibleValue = (section, target, localizedDigits) => {\n  let value = section.value || section.placeholder;\n  const hasLeadingZeros = target === 'non-input' ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;\n  if (target === 'non-input' && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {\n    value = Number(removeLocalizedDigits(value, localizedDigits)).toString();\n  }\n\n  // In the input, we add an empty character at the end of each section without leading zeros.\n  // This makes sure that `onChange` will always be fired.\n  // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),\n  // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,\n  // So the browser will not fire the input `onChange`.\n  const shouldAddInvisibleSpace = ['input-rtl', 'input-ltr'].includes(target) && section.contentType === 'digit' && !hasLeadingZeros && value.length === 1;\n  if (shouldAddInvisibleSpace) {\n    value = \"\".concat(value, \"\\u200E\");\n  }\n  if (target === 'input-rtl') {\n    value = \"\\u2068\".concat(value, \"\\u2069\");\n  }\n  return value;\n};\nexport const changeSectionValueFormat = (adapter, valueStr, currentFormat, newFormat) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (getDateSectionConfigFromFormatToken(adapter, currentFormat).type === 'weekDay') {\n      throw new Error(\"changeSectionValueFormat doesn't support week day formats\");\n    }\n  }\n  return adapter.formatByString(adapter.parse(valueStr, currentFormat), newFormat);\n};\nconst isFourDigitYearFormat = (adapter, format) => adapter.formatByString(adapter.date(undefined, 'system'), format).length === 4;\nexport const doesSectionFormatHaveLeadingZeros = (adapter, contentType, sectionType, format) => {\n  if (contentType !== 'digit') {\n    return false;\n  }\n  const now = adapter.date(undefined, 'default');\n  switch (sectionType) {\n    // We can't use `changeSectionValueFormat`, because  `adapter.parse('1', 'YYYY')` returns `1971` instead of `1`.\n    case 'year':\n      {\n        // Remove once https://github.com/iamkun/dayjs/pull/2847 is merged and bump dayjs version\n        if (adapter.lib === 'dayjs' && format === 'YY') {\n          return true;\n        }\n        return adapter.formatByString(adapter.setYear(now, 1), format).startsWith('0');\n      }\n    case 'month':\n      {\n        return adapter.formatByString(adapter.startOfYear(now), format).length > 1;\n      }\n    case 'day':\n      {\n        return adapter.formatByString(adapter.startOfMonth(now), format).length > 1;\n      }\n    case 'weekDay':\n      {\n        return adapter.formatByString(adapter.startOfWeek(now), format).length > 1;\n      }\n    case 'hours':\n      {\n        return adapter.formatByString(adapter.setHours(now, 1), format).length > 1;\n      }\n    case 'minutes':\n      {\n        return adapter.formatByString(adapter.setMinutes(now, 1), format).length > 1;\n      }\n    case 'seconds':\n      {\n        return adapter.formatByString(adapter.setSeconds(now, 1), format).length > 1;\n      }\n    default:\n      {\n        throw new Error('Invalid section type');\n      }\n  }\n};\n\n/**\n * Some date libraries like `dayjs` don't support parsing from date with escaped characters.\n * To make sure that the parsing works, we are building a format and a date without any separator.\n */\nexport const getDateFromDateSections = (adapter, sections, localizedDigits) => {\n  // If we have both a day and a weekDay section,\n  // Then we skip the weekDay in the parsing because libraries like dayjs can't parse complicated formats containing a weekDay.\n  // dayjs(dayjs().format('dddd MMMM D YYYY'), 'dddd MMMM D YYYY')) // returns `Invalid Date` even if the format is valid.\n  const shouldSkipWeekDays = sections.some(section => section.type === 'day');\n  const sectionFormats = [];\n  const sectionValues = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const shouldSkip = shouldSkipWeekDays && section.type === 'weekDay';\n    if (!shouldSkip) {\n      sectionFormats.push(section.format);\n      sectionValues.push(getSectionVisibleValue(section, 'non-input', localizedDigits));\n    }\n  }\n  const formatWithoutSeparator = sectionFormats.join(' ');\n  const dateWithoutSeparatorStr = sectionValues.join(' ');\n  return adapter.parse(dateWithoutSeparatorStr, formatWithoutSeparator);\n};\nexport const createDateStrForV7HiddenInputFromSections = sections => sections.map(section => {\n  return \"\".concat(section.startSeparator).concat(section.value || section.placeholder).concat(section.endSeparator);\n}).join('');\nexport const createDateStrForV6InputFromSections = (sections, localizedDigits, isRtl) => {\n  const formattedSections = sections.map(section => {\n    const dateValue = getSectionVisibleValue(section, isRtl ? 'input-rtl' : 'input-ltr', localizedDigits);\n    return \"\".concat(section.startSeparator).concat(dateValue).concat(section.endSeparator);\n  });\n  const dateStr = formattedSections.join('');\n  if (!isRtl) {\n    return dateStr;\n  }\n\n  // \\u2066: start left-to-right isolation\n  // \\u2067: start right-to-left isolation\n  // \\u2068: start first strong character isolation\n  // \\u2069: pop isolation\n  // wrap into an isolated group such that separators can split the string in smaller ones by adding \\u2069\\u2068\n  return \"\\u2066\".concat(dateStr, \"\\u2069\");\n};\nexport const getSectionsBoundaries = (adapter, localizedDigits, timezone) => {\n  const today = adapter.date(undefined, timezone);\n  const endOfYear = adapter.endOfYear(today);\n  const endOfDay = adapter.endOfDay(today);\n  const {\n    maxDaysInMonth,\n    longestMonth\n  } = getMonthsInYear(adapter, today).reduce((acc, month) => {\n    const daysInMonth = adapter.getDaysInMonth(month);\n    if (daysInMonth > acc.maxDaysInMonth) {\n      return {\n        maxDaysInMonth: daysInMonth,\n        longestMonth: month\n      };\n    }\n    return acc;\n  }, {\n    maxDaysInMonth: 0,\n    longestMonth: null\n  });\n  return {\n    year: _ref => {\n      let {\n        format\n      } = _ref;\n      return {\n        minimum: 0,\n        maximum: isFourDigitYearFormat(adapter, format) ? 9999 : 99\n      };\n    },\n    month: () => ({\n      minimum: 1,\n      // Assumption: All years have the same amount of months\n      maximum: adapter.getMonth(endOfYear) + 1\n    }),\n    day: _ref2 => {\n      let {\n        currentDate\n      } = _ref2;\n      return {\n        minimum: 1,\n        maximum: adapter.isValid(currentDate) ? adapter.getDaysInMonth(currentDate) : maxDaysInMonth,\n        longestMonth: longestMonth\n      };\n    },\n    weekDay: _ref3 => {\n      let {\n        format,\n        contentType\n      } = _ref3;\n      if (contentType === 'digit') {\n        const daysInWeek = getDaysInWeekStr(adapter, format).map(Number);\n        return {\n          minimum: Math.min(...daysInWeek),\n          maximum: Math.max(...daysInWeek)\n        };\n      }\n      return {\n        minimum: 1,\n        maximum: 7\n      };\n    },\n    hours: _ref4 => {\n      let {\n        format\n      } = _ref4;\n      const lastHourInDay = adapter.getHours(endOfDay);\n      const hasMeridiem = removeLocalizedDigits(adapter.formatByString(adapter.endOfDay(today), format), localizedDigits) !== lastHourInDay.toString();\n      if (hasMeridiem) {\n        return {\n          minimum: 1,\n          maximum: Number(removeLocalizedDigits(adapter.formatByString(adapter.startOfDay(today), format), localizedDigits))\n        };\n      }\n      return {\n        minimum: 0,\n        maximum: lastHourInDay\n      };\n    },\n    minutes: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of minutes\n      maximum: adapter.getMinutes(endOfDay)\n    }),\n    seconds: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of seconds\n      maximum: adapter.getSeconds(endOfDay)\n    }),\n    meridiem: () => ({\n      minimum: 0,\n      maximum: 1\n    }),\n    empty: () => ({\n      minimum: 0,\n      maximum: 0\n    })\n  };\n};\nlet warnedOnceInvalidSection = false;\nexport const validateSections = (sections, valueType) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!warnedOnceInvalidSection) {\n      const supportedSections = ['empty'];\n      if (['date', 'date-time'].includes(valueType)) {\n        supportedSections.push('weekDay', 'day', 'month', 'year');\n      }\n      if (['time', 'date-time'].includes(valueType)) {\n        supportedSections.push('hours', 'minutes', 'seconds', 'meridiem');\n      }\n      const invalidSection = sections.find(section => !supportedSections.includes(section.type));\n      if (invalidSection) {\n        console.warn(\"MUI X: The field component you are using is not compatible with the \\\"\".concat(invalidSection.type, \"\\\" date section.\"), \"The supported date sections are [\\\"\".concat(supportedSections.join('\", \"'), \"\\\"]`.\"));\n        warnedOnceInvalidSection = true;\n      }\n    }\n  }\n};\nconst transferDateSectionValue = (adapter, section, dateToTransferFrom, dateToTransferTo) => {\n  switch (section.type) {\n    case 'year':\n      {\n        return adapter.setYear(dateToTransferTo, adapter.getYear(dateToTransferFrom));\n      }\n    case 'month':\n      {\n        return adapter.setMonth(dateToTransferTo, adapter.getMonth(dateToTransferFrom));\n      }\n    case 'weekDay':\n      {\n        let dayInWeekStrOfActiveDate = adapter.formatByString(dateToTransferFrom, section.format);\n        if (section.hasLeadingZerosInInput) {\n          dayInWeekStrOfActiveDate = cleanLeadingZeros(dayInWeekStrOfActiveDate, section.maxLength);\n        }\n        const formattedDaysInWeek = getDaysInWeekStr(adapter, section.format);\n        const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);\n        const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);\n        const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;\n        return adapter.addDays(dateToTransferFrom, diff);\n      }\n    case 'day':\n      {\n        return adapter.setDate(dateToTransferTo, adapter.getDate(dateToTransferFrom));\n      }\n    case 'meridiem':\n      {\n        const isAM = adapter.getHours(dateToTransferFrom) < 12;\n        const mergedDateHours = adapter.getHours(dateToTransferTo);\n        if (isAM && mergedDateHours >= 12) {\n          return adapter.addHours(dateToTransferTo, -12);\n        }\n        if (!isAM && mergedDateHours < 12) {\n          return adapter.addHours(dateToTransferTo, 12);\n        }\n        return dateToTransferTo;\n      }\n    case 'hours':\n      {\n        return adapter.setHours(dateToTransferTo, adapter.getHours(dateToTransferFrom));\n      }\n    case 'minutes':\n      {\n        return adapter.setMinutes(dateToTransferTo, adapter.getMinutes(dateToTransferFrom));\n      }\n    case 'seconds':\n      {\n        return adapter.setSeconds(dateToTransferTo, adapter.getSeconds(dateToTransferFrom));\n      }\n    default:\n      {\n        return dateToTransferTo;\n      }\n  }\n};\nconst reliableSectionModificationOrder = {\n  year: 1,\n  month: 2,\n  day: 3,\n  weekDay: 4,\n  hours: 5,\n  minutes: 6,\n  seconds: 7,\n  meridiem: 8,\n  empty: 9\n};\nexport const mergeDateIntoReferenceDate = (adapter, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) =>\n// cloning sections before sort to avoid mutating it\n[...sections].sort((a, b) => reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b.type]).reduce((mergedDate, section) => {\n  if (!shouldLimitToEditedSections || section.modified) {\n    return transferDateSectionValue(adapter, section, dateToTransferFrom, mergedDate);\n  }\n  return mergedDate;\n}, referenceDate);\nexport const isAndroid = () => navigator.userAgent.toLowerCase().includes('android');\n\n// TODO v9: Remove\nexport const getSectionOrder = (sections, shouldApplyRTL) => {\n  const neighbors = {};\n  if (!shouldApplyRTL) {\n    sections.forEach((_, index) => {\n      const leftIndex = index === 0 ? null : index - 1;\n      const rightIndex = index === sections.length - 1 ? null : index + 1;\n      neighbors[index] = {\n        leftIndex,\n        rightIndex\n      };\n    });\n    return {\n      neighbors,\n      startIndex: 0,\n      endIndex: sections.length - 1\n    };\n  }\n  const rtl2ltr = {};\n  const ltr2rtl = {};\n  let groupedSectionsStart = 0;\n  let groupedSectionsEnd = 0;\n  let RTLIndex = sections.length - 1;\n  while (RTLIndex >= 0) {\n    groupedSectionsEnd = sections.findIndex(\n    // eslint-disable-next-line @typescript-eslint/no-loop-func\n    (section, index) => {\n      var _section$endSeparator;\n      return index >= groupedSectionsStart && ((_section$endSeparator = section.endSeparator) === null || _section$endSeparator === void 0 ? void 0 : _section$endSeparator.includes(' ')) &&\n      // Special case where the spaces were not there in the initial input\n      section.endSeparator !== ' / ';\n    });\n    if (groupedSectionsEnd === -1) {\n      groupedSectionsEnd = sections.length - 1;\n    }\n    for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {\n      ltr2rtl[i] = RTLIndex;\n      rtl2ltr[RTLIndex] = i;\n      RTLIndex -= 1;\n    }\n    groupedSectionsStart = groupedSectionsEnd + 1;\n  }\n  sections.forEach((_, index) => {\n    const rtlIndex = ltr2rtl[index];\n    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];\n    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];\n    neighbors[index] = {\n      leftIndex,\n      rightIndex\n    };\n  });\n  return {\n    neighbors,\n    startIndex: rtl2ltr[0],\n    endIndex: rtl2ltr[sections.length - 1]\n  };\n};\nexport const parseSelectedSections = (selectedSections, sections) => {\n  if (selectedSections == null) {\n    return null;\n  }\n  if (selectedSections === 'all') {\n    return 'all';\n  }\n  if (typeof selectedSections === 'string') {\n    const index = sections.findIndex(section => section.type === selectedSections);\n    return index === -1 ? null : index;\n  }\n  return selectedSections;\n};","map":{"version":3,"names":["getMonthsInYear","getDateSectionConfigFromFormatToken","adapter","formatToken","config","formatTokenMap","Error","concat","join","type","contentType","maxLength","undefined","sectionType","getDaysInWeekStr","format","elements","now","date","startDate","startOfWeek","endDate","endOfWeek","current","isBefore","push","addDays","map","weekDay","formatByString","getLetterEditingOptions","timezone","month","startOfDay","endOfDay","FORMAT_SECONDS_NO_LEADING_ZEROS","NON_LOCALIZED_DIGITS","getLocalizedDigits","today","formattedZero","setSeconds","Array","from","length","_","index","removeLocalizedDigits","valueStr","localizedDigits","digits","currentFormattedDigit","i","matchingDigitIndex","indexOf","toString","applyLocalizedDigits","split","char","Number","isStringNumber","nonLocalizedValueStr","isNaN","cleanLeadingZeros","size","padStart","cleanDigitSectionValue","value","sectionBoundaries","section","process","env","NODE_ENV","setDate","longestMonth","hasLeadingZerosInInput","getSectionVisibleValue","target","placeholder","hasLeadingZeros","hasLeadingZerosInFormat","shouldAddInvisibleSpace","includes","changeSectionValueFormat","currentFormat","newFormat","parse","isFourDigitYearFormat","doesSectionFormatHaveLeadingZeros","lib","setYear","startsWith","startOfYear","startOfMonth","setHours","setMinutes","getDateFromDateSections","sections","shouldSkipWeekDays","some","sectionFormats","sectionValues","shouldSkip","formatWithoutSeparator","dateWithoutSeparatorStr","createDateStrForV7HiddenInputFromSections","startSeparator","endSeparator","createDateStrForV6InputFromSections","isRtl","formattedSections","dateValue","dateStr","getSectionsBoundaries","endOfYear","maxDaysInMonth","reduce","acc","daysInMonth","getDaysInMonth","year","_ref","minimum","maximum","getMonth","day","_ref2","currentDate","isValid","_ref3","daysInWeek","Math","min","max","hours","_ref4","lastHourInDay","getHours","hasMeridiem","minutes","getMinutes","seconds","getSeconds","meridiem","empty","warnedOnceInvalidSection","validateSections","valueType","supportedSections","invalidSection","find","console","warn","transferDateSectionValue","dateToTransferFrom","dateToTransferTo","getYear","setMonth","dayInWeekStrOfActiveDate","formattedDaysInWeek","dayInWeekOfActiveDate","dayInWeekOfNewSectionValue","diff","getDate","isAM","mergedDateHours","addHours","reliableSectionModificationOrder","mergeDateIntoReferenceDate","referenceDate","shouldLimitToEditedSections","sort","a","b","mergedDate","modified","isAndroid","navigator","userAgent","toLowerCase","getSectionOrder","shouldApplyRTL","neighbors","forEach","leftIndex","rightIndex","startIndex","endIndex","rtl2ltr","ltr2rtl","groupedSectionsStart","groupedSectionsEnd","RTLIndex","findIndex","_section$endSeparator","rtlIndex","parseSelectedSections","selectedSections"],"sources":["/home/ubuntu/application/frontend/node_modules/@mui/x-date-pickers/esm/internals/hooks/useField/useField.utils.js"],"sourcesContent":["import { getMonthsInYear } from \"../../utils/date-utils.js\";\nexport const getDateSectionConfigFromFormatToken = (adapter, formatToken) => {\n  const config = adapter.formatTokenMap[formatToken];\n  if (config == null) {\n    throw new Error([`MUI X: The token \"${formatToken}\" is not supported by the Date and Time Pickers.`, 'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.'].join('\\n'));\n  }\n  if (typeof config === 'string') {\n    return {\n      type: config,\n      contentType: config === 'meridiem' ? 'letter' : 'digit',\n      maxLength: undefined\n    };\n  }\n  return {\n    type: config.sectionType,\n    contentType: config.contentType,\n    maxLength: config.maxLength\n  };\n};\nexport const getDaysInWeekStr = (adapter, format) => {\n  const elements = [];\n  const now = adapter.date(undefined, 'default');\n  const startDate = adapter.startOfWeek(now);\n  const endDate = adapter.endOfWeek(now);\n  let current = startDate;\n  while (adapter.isBefore(current, endDate)) {\n    elements.push(current);\n    current = adapter.addDays(current, 1);\n  }\n  return elements.map(weekDay => adapter.formatByString(weekDay, format));\n};\nexport const getLetterEditingOptions = (adapter, timezone, sectionType, format) => {\n  switch (sectionType) {\n    case 'month':\n      {\n        return getMonthsInYear(adapter, adapter.date(undefined, timezone)).map(month => adapter.formatByString(month, format));\n      }\n    case 'weekDay':\n      {\n        return getDaysInWeekStr(adapter, format);\n      }\n    case 'meridiem':\n      {\n        const now = adapter.date(undefined, timezone);\n        return [adapter.startOfDay(now), adapter.endOfDay(now)].map(date => adapter.formatByString(date, format));\n      }\n    default:\n      {\n        return [];\n      }\n  }\n};\n\n// This format should be the same on all the adapters\n// If some adapter does not respect this convention, then we will need to hardcode the format on each adapter.\nexport const FORMAT_SECONDS_NO_LEADING_ZEROS = 's';\nconst NON_LOCALIZED_DIGITS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\nexport const getLocalizedDigits = adapter => {\n  const today = adapter.date(undefined);\n  const formattedZero = adapter.formatByString(adapter.setSeconds(today, 0), FORMAT_SECONDS_NO_LEADING_ZEROS);\n  if (formattedZero === '0') {\n    return NON_LOCALIZED_DIGITS;\n  }\n  return Array.from({\n    length: 10\n  }).map((_, index) => adapter.formatByString(adapter.setSeconds(today, index), FORMAT_SECONDS_NO_LEADING_ZEROS));\n};\nexport const removeLocalizedDigits = (valueStr, localizedDigits) => {\n  if (localizedDigits[0] === '0') {\n    return valueStr;\n  }\n  const digits = [];\n  let currentFormattedDigit = '';\n  for (let i = 0; i < valueStr.length; i += 1) {\n    currentFormattedDigit += valueStr[i];\n    const matchingDigitIndex = localizedDigits.indexOf(currentFormattedDigit);\n    if (matchingDigitIndex > -1) {\n      digits.push(matchingDigitIndex.toString());\n      currentFormattedDigit = '';\n    }\n  }\n  return digits.join('');\n};\nexport const applyLocalizedDigits = (valueStr, localizedDigits) => {\n  if (localizedDigits[0] === '0') {\n    return valueStr;\n  }\n  return valueStr.split('').map(char => localizedDigits[Number(char)]).join('');\n};\nexport const isStringNumber = (valueStr, localizedDigits) => {\n  const nonLocalizedValueStr = removeLocalizedDigits(valueStr, localizedDigits);\n  // `Number(' ')` returns `0` even if ' ' is not a valid number.\n  return nonLocalizedValueStr !== ' ' && !Number.isNaN(Number(nonLocalizedValueStr));\n};\n\n/**\n * Make sure the value of a digit section have the right amount of leading zeros.\n * E.g.: `03` => `3`\n * Warning: Should only be called with non-localized digits. Call `removeLocalizedDigits` with your value if needed.\n */\nexport const cleanLeadingZeros = (valueStr, size) => {\n  // Remove the leading zeros and then add back as many as needed.\n  return Number(valueStr).toString().padStart(size, '0');\n};\nexport const cleanDigitSectionValue = (adapter, value, sectionBoundaries, localizedDigits, section) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (section.type !== 'day' && section.contentType === 'digit-with-letter') {\n      throw new Error([`MUI X: The token \"${section.format}\" is a digit format with letter in it.'\n             This type of format is only supported for 'day' sections`].join('\\n'));\n    }\n  }\n  if (section.type === 'day' && section.contentType === 'digit-with-letter') {\n    const date = adapter.setDate(sectionBoundaries.longestMonth, value);\n    return adapter.formatByString(date, section.format);\n  }\n\n  // queryValue without leading `0` (`01` => `1`)\n  let valueStr = value.toString();\n  if (section.hasLeadingZerosInInput) {\n    valueStr = cleanLeadingZeros(valueStr, section.maxLength);\n  }\n  return applyLocalizedDigits(valueStr, localizedDigits);\n};\nexport const getSectionVisibleValue = (section, target, localizedDigits) => {\n  let value = section.value || section.placeholder;\n  const hasLeadingZeros = target === 'non-input' ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;\n  if (target === 'non-input' && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {\n    value = Number(removeLocalizedDigits(value, localizedDigits)).toString();\n  }\n\n  // In the input, we add an empty character at the end of each section without leading zeros.\n  // This makes sure that `onChange` will always be fired.\n  // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),\n  // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,\n  // So the browser will not fire the input `onChange`.\n  const shouldAddInvisibleSpace = ['input-rtl', 'input-ltr'].includes(target) && section.contentType === 'digit' && !hasLeadingZeros && value.length === 1;\n  if (shouldAddInvisibleSpace) {\n    value = `${value}\\u200e`;\n  }\n  if (target === 'input-rtl') {\n    value = `\\u2068${value}\\u2069`;\n  }\n  return value;\n};\nexport const changeSectionValueFormat = (adapter, valueStr, currentFormat, newFormat) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (getDateSectionConfigFromFormatToken(adapter, currentFormat).type === 'weekDay') {\n      throw new Error(\"changeSectionValueFormat doesn't support week day formats\");\n    }\n  }\n  return adapter.formatByString(adapter.parse(valueStr, currentFormat), newFormat);\n};\nconst isFourDigitYearFormat = (adapter, format) => adapter.formatByString(adapter.date(undefined, 'system'), format).length === 4;\nexport const doesSectionFormatHaveLeadingZeros = (adapter, contentType, sectionType, format) => {\n  if (contentType !== 'digit') {\n    return false;\n  }\n  const now = adapter.date(undefined, 'default');\n  switch (sectionType) {\n    // We can't use `changeSectionValueFormat`, because  `adapter.parse('1', 'YYYY')` returns `1971` instead of `1`.\n    case 'year':\n      {\n        // Remove once https://github.com/iamkun/dayjs/pull/2847 is merged and bump dayjs version\n        if (adapter.lib === 'dayjs' && format === 'YY') {\n          return true;\n        }\n        return adapter.formatByString(adapter.setYear(now, 1), format).startsWith('0');\n      }\n    case 'month':\n      {\n        return adapter.formatByString(adapter.startOfYear(now), format).length > 1;\n      }\n    case 'day':\n      {\n        return adapter.formatByString(adapter.startOfMonth(now), format).length > 1;\n      }\n    case 'weekDay':\n      {\n        return adapter.formatByString(adapter.startOfWeek(now), format).length > 1;\n      }\n    case 'hours':\n      {\n        return adapter.formatByString(adapter.setHours(now, 1), format).length > 1;\n      }\n    case 'minutes':\n      {\n        return adapter.formatByString(adapter.setMinutes(now, 1), format).length > 1;\n      }\n    case 'seconds':\n      {\n        return adapter.formatByString(adapter.setSeconds(now, 1), format).length > 1;\n      }\n    default:\n      {\n        throw new Error('Invalid section type');\n      }\n  }\n};\n\n/**\n * Some date libraries like `dayjs` don't support parsing from date with escaped characters.\n * To make sure that the parsing works, we are building a format and a date without any separator.\n */\nexport const getDateFromDateSections = (adapter, sections, localizedDigits) => {\n  // If we have both a day and a weekDay section,\n  // Then we skip the weekDay in the parsing because libraries like dayjs can't parse complicated formats containing a weekDay.\n  // dayjs(dayjs().format('dddd MMMM D YYYY'), 'dddd MMMM D YYYY')) // returns `Invalid Date` even if the format is valid.\n  const shouldSkipWeekDays = sections.some(section => section.type === 'day');\n  const sectionFormats = [];\n  const sectionValues = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const shouldSkip = shouldSkipWeekDays && section.type === 'weekDay';\n    if (!shouldSkip) {\n      sectionFormats.push(section.format);\n      sectionValues.push(getSectionVisibleValue(section, 'non-input', localizedDigits));\n    }\n  }\n  const formatWithoutSeparator = sectionFormats.join(' ');\n  const dateWithoutSeparatorStr = sectionValues.join(' ');\n  return adapter.parse(dateWithoutSeparatorStr, formatWithoutSeparator);\n};\nexport const createDateStrForV7HiddenInputFromSections = sections => sections.map(section => {\n  return `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`;\n}).join('');\nexport const createDateStrForV6InputFromSections = (sections, localizedDigits, isRtl) => {\n  const formattedSections = sections.map(section => {\n    const dateValue = getSectionVisibleValue(section, isRtl ? 'input-rtl' : 'input-ltr', localizedDigits);\n    return `${section.startSeparator}${dateValue}${section.endSeparator}`;\n  });\n  const dateStr = formattedSections.join('');\n  if (!isRtl) {\n    return dateStr;\n  }\n\n  // \\u2066: start left-to-right isolation\n  // \\u2067: start right-to-left isolation\n  // \\u2068: start first strong character isolation\n  // \\u2069: pop isolation\n  // wrap into an isolated group such that separators can split the string in smaller ones by adding \\u2069\\u2068\n  return `\\u2066${dateStr}\\u2069`;\n};\nexport const getSectionsBoundaries = (adapter, localizedDigits, timezone) => {\n  const today = adapter.date(undefined, timezone);\n  const endOfYear = adapter.endOfYear(today);\n  const endOfDay = adapter.endOfDay(today);\n  const {\n    maxDaysInMonth,\n    longestMonth\n  } = getMonthsInYear(adapter, today).reduce((acc, month) => {\n    const daysInMonth = adapter.getDaysInMonth(month);\n    if (daysInMonth > acc.maxDaysInMonth) {\n      return {\n        maxDaysInMonth: daysInMonth,\n        longestMonth: month\n      };\n    }\n    return acc;\n  }, {\n    maxDaysInMonth: 0,\n    longestMonth: null\n  });\n  return {\n    year: ({\n      format\n    }) => ({\n      minimum: 0,\n      maximum: isFourDigitYearFormat(adapter, format) ? 9999 : 99\n    }),\n    month: () => ({\n      minimum: 1,\n      // Assumption: All years have the same amount of months\n      maximum: adapter.getMonth(endOfYear) + 1\n    }),\n    day: ({\n      currentDate\n    }) => ({\n      minimum: 1,\n      maximum: adapter.isValid(currentDate) ? adapter.getDaysInMonth(currentDate) : maxDaysInMonth,\n      longestMonth: longestMonth\n    }),\n    weekDay: ({\n      format,\n      contentType\n    }) => {\n      if (contentType === 'digit') {\n        const daysInWeek = getDaysInWeekStr(adapter, format).map(Number);\n        return {\n          minimum: Math.min(...daysInWeek),\n          maximum: Math.max(...daysInWeek)\n        };\n      }\n      return {\n        minimum: 1,\n        maximum: 7\n      };\n    },\n    hours: ({\n      format\n    }) => {\n      const lastHourInDay = adapter.getHours(endOfDay);\n      const hasMeridiem = removeLocalizedDigits(adapter.formatByString(adapter.endOfDay(today), format), localizedDigits) !== lastHourInDay.toString();\n      if (hasMeridiem) {\n        return {\n          minimum: 1,\n          maximum: Number(removeLocalizedDigits(adapter.formatByString(adapter.startOfDay(today), format), localizedDigits))\n        };\n      }\n      return {\n        minimum: 0,\n        maximum: lastHourInDay\n      };\n    },\n    minutes: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of minutes\n      maximum: adapter.getMinutes(endOfDay)\n    }),\n    seconds: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of seconds\n      maximum: adapter.getSeconds(endOfDay)\n    }),\n    meridiem: () => ({\n      minimum: 0,\n      maximum: 1\n    }),\n    empty: () => ({\n      minimum: 0,\n      maximum: 0\n    })\n  };\n};\nlet warnedOnceInvalidSection = false;\nexport const validateSections = (sections, valueType) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!warnedOnceInvalidSection) {\n      const supportedSections = ['empty'];\n      if (['date', 'date-time'].includes(valueType)) {\n        supportedSections.push('weekDay', 'day', 'month', 'year');\n      }\n      if (['time', 'date-time'].includes(valueType)) {\n        supportedSections.push('hours', 'minutes', 'seconds', 'meridiem');\n      }\n      const invalidSection = sections.find(section => !supportedSections.includes(section.type));\n      if (invalidSection) {\n        console.warn(`MUI X: The field component you are using is not compatible with the \"${invalidSection.type}\" date section.`, `The supported date sections are [\"${supportedSections.join('\", \"')}\"]\\`.`);\n        warnedOnceInvalidSection = true;\n      }\n    }\n  }\n};\nconst transferDateSectionValue = (adapter, section, dateToTransferFrom, dateToTransferTo) => {\n  switch (section.type) {\n    case 'year':\n      {\n        return adapter.setYear(dateToTransferTo, adapter.getYear(dateToTransferFrom));\n      }\n    case 'month':\n      {\n        return adapter.setMonth(dateToTransferTo, adapter.getMonth(dateToTransferFrom));\n      }\n    case 'weekDay':\n      {\n        let dayInWeekStrOfActiveDate = adapter.formatByString(dateToTransferFrom, section.format);\n        if (section.hasLeadingZerosInInput) {\n          dayInWeekStrOfActiveDate = cleanLeadingZeros(dayInWeekStrOfActiveDate, section.maxLength);\n        }\n        const formattedDaysInWeek = getDaysInWeekStr(adapter, section.format);\n        const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);\n        const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);\n        const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;\n        return adapter.addDays(dateToTransferFrom, diff);\n      }\n    case 'day':\n      {\n        return adapter.setDate(dateToTransferTo, adapter.getDate(dateToTransferFrom));\n      }\n    case 'meridiem':\n      {\n        const isAM = adapter.getHours(dateToTransferFrom) < 12;\n        const mergedDateHours = adapter.getHours(dateToTransferTo);\n        if (isAM && mergedDateHours >= 12) {\n          return adapter.addHours(dateToTransferTo, -12);\n        }\n        if (!isAM && mergedDateHours < 12) {\n          return adapter.addHours(dateToTransferTo, 12);\n        }\n        return dateToTransferTo;\n      }\n    case 'hours':\n      {\n        return adapter.setHours(dateToTransferTo, adapter.getHours(dateToTransferFrom));\n      }\n    case 'minutes':\n      {\n        return adapter.setMinutes(dateToTransferTo, adapter.getMinutes(dateToTransferFrom));\n      }\n    case 'seconds':\n      {\n        return adapter.setSeconds(dateToTransferTo, adapter.getSeconds(dateToTransferFrom));\n      }\n    default:\n      {\n        return dateToTransferTo;\n      }\n  }\n};\nconst reliableSectionModificationOrder = {\n  year: 1,\n  month: 2,\n  day: 3,\n  weekDay: 4,\n  hours: 5,\n  minutes: 6,\n  seconds: 7,\n  meridiem: 8,\n  empty: 9\n};\nexport const mergeDateIntoReferenceDate = (adapter, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) =>\n// cloning sections before sort to avoid mutating it\n[...sections].sort((a, b) => reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b.type]).reduce((mergedDate, section) => {\n  if (!shouldLimitToEditedSections || section.modified) {\n    return transferDateSectionValue(adapter, section, dateToTransferFrom, mergedDate);\n  }\n  return mergedDate;\n}, referenceDate);\nexport const isAndroid = () => navigator.userAgent.toLowerCase().includes('android');\n\n// TODO v9: Remove\nexport const getSectionOrder = (sections, shouldApplyRTL) => {\n  const neighbors = {};\n  if (!shouldApplyRTL) {\n    sections.forEach((_, index) => {\n      const leftIndex = index === 0 ? null : index - 1;\n      const rightIndex = index === sections.length - 1 ? null : index + 1;\n      neighbors[index] = {\n        leftIndex,\n        rightIndex\n      };\n    });\n    return {\n      neighbors,\n      startIndex: 0,\n      endIndex: sections.length - 1\n    };\n  }\n  const rtl2ltr = {};\n  const ltr2rtl = {};\n  let groupedSectionsStart = 0;\n  let groupedSectionsEnd = 0;\n  let RTLIndex = sections.length - 1;\n  while (RTLIndex >= 0) {\n    groupedSectionsEnd = sections.findIndex(\n    // eslint-disable-next-line @typescript-eslint/no-loop-func\n    (section, index) => index >= groupedSectionsStart && section.endSeparator?.includes(' ') &&\n    // Special case where the spaces were not there in the initial input\n    section.endSeparator !== ' / ');\n    if (groupedSectionsEnd === -1) {\n      groupedSectionsEnd = sections.length - 1;\n    }\n    for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {\n      ltr2rtl[i] = RTLIndex;\n      rtl2ltr[RTLIndex] = i;\n      RTLIndex -= 1;\n    }\n    groupedSectionsStart = groupedSectionsEnd + 1;\n  }\n  sections.forEach((_, index) => {\n    const rtlIndex = ltr2rtl[index];\n    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];\n    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];\n    neighbors[index] = {\n      leftIndex,\n      rightIndex\n    };\n  });\n  return {\n    neighbors,\n    startIndex: rtl2ltr[0],\n    endIndex: rtl2ltr[sections.length - 1]\n  };\n};\nexport const parseSelectedSections = (selectedSections, sections) => {\n  if (selectedSections == null) {\n    return null;\n  }\n  if (selectedSections === 'all') {\n    return 'all';\n  }\n  if (typeof selectedSections === 'string') {\n    const index = sections.findIndex(section => section.type === selectedSections);\n    return index === -1 ? null : index;\n  }\n  return selectedSections;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}